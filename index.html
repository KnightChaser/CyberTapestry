<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>Entropy drawing</title>
    <style>
      :root {
        --bg0: #05070c;
        --bg1: #0c1220;
        --bg2: #0b1224;
        --fg: #cfe8ff;
        --muted: #8aa3bf;
        --neon: #5bd3ff;
        --neon2: #7cf7d4;
        --edge: #1a2436;
        --panel: #0b1324;
        --panel2: #0d172d;
        --accent: #91c8e4;
      }
      * {
        box-sizing: border-box;
      }
      html,
      body {
        height: 100%;
      }
      body {
        margin: 0;
        padding: 28px;
        background: radial-gradient(
            1100px 700px at 20% 10%,
            #0e1a33 0%,
            var(--bg1) 45%,
            var(--bg0) 100%
          ),
          linear-gradient(180deg, #060912 0%, #02050a 100%);
        color: var(--fg);
        font-family: ui-monospace, SFMono-Regular, Consolas, "Liberation Mono",
          Menlo, monospace;
        display: grid;
        place-items: start center;
      }
      .wrap {
        width: min(900px, 100%);
        display: grid;
        gap: 16px;
      }
      .title {
        font-size: 22px;
        letter-spacing: 0.4px;
        display: flex;
        align-items: center;
        gap: 12px;
        text-shadow: 0 0 10px rgba(91, 211, 255, 0.35),
          0 0 18px rgba(124, 247, 212, 0.18);
      }
      .glow-dot {
        width: 10px;
        height: 10px;
        border-radius: 50%;
        background: radial-gradient(
          circle,
          var(--neon) 0%,
          #1fb2ff 60%,
          transparent 70%
        );
        box-shadow: 0 0 16px var(--neon), 0 0 36px rgba(124, 247, 212, 0.35);
      }
      .panel {
        background: linear-gradient(
          180deg,
          var(--panel) 0%,
          var(--panel2) 100%
        );
        border: 1px solid var(--edge);
        border-radius: 14px;
        padding: 14px;
        box-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.03),
          0 10px 30px rgba(9, 20, 40, 0.35), 0 0 30px rgba(91, 211, 255, 0.08);
      }
      .row {
        display: flex;
        gap: 10px;
        align-items: center;
        flex-wrap: wrap;
      }
      input[type="text"] {
        flex: 1 1 420px;
        padding: 12px 14px;
        font-size: 14px;
        letter-spacing: 0.3px;
        color: var(--fg);
        background: #0a1326;
        border: 1px solid #14223a;
        border-radius: 10px;
        outline: none;
        transition: box-shadow 0.2s, border-color 0.2s;
      }
      input[type="text"]::placeholder {
        color: var(--muted);
      }
      input[type="text"]:focus {
        border-color: #224a72;
        box-shadow: 0 0 0 3px rgba(91, 211, 255, 0.12);
      }
      button {
        padding: 10px 14px;
        border: 1px solid #1b2a44;
        background: #0c182f;
        color: var(--fg);
        border-radius: 10px;
        cursor: pointer;
        letter-spacing: 0.2px;
        box-shadow: 0 0 12px rgba(91, 211, 255, 0.12),
          inset 0 1px 0 rgba(255, 255, 255, 0.05);
      }
      button:hover {
        background: #0f2041;
        box-shadow: 0 0 18px rgba(124, 247, 212, 0.18);
      }
      .primary {
        border-color: #23507d;
        background: linear-gradient(180deg, #0e1d3a 0%, #0c162c 100%);
      }
      .canvas-wrap {
        display: flex;
        gap: 18px;
        align-items: flex-start;
      }
      canvas {
        width: 512px;
        height: 512px;
        image-rendering: pixelated;
        image-rendering: crisp-edges;
        border-radius: 12px;
        background: #08101d;
        border: 1px solid #14223a;
        box-shadow: 0 0 24px rgba(91, 211, 255, 0.08),
          inset 0 0 40px rgba(124, 247, 212, 0.04);
      }
      .meta {
        color: var(--muted);
        font-size: 12px;
        line-height: 1.4;
        display: grid;
        gap: 8px;
      }
      .badges {
        display: flex;
        gap: 8px;
        flex-wrap: wrap;
      }
      .badge {
        padding: 3px 8px;
        border-radius: 8px;
        border: 1px solid #163356;
        background: #0a1730;
        color: #bfe5ff;
        box-shadow: 0 0 12px rgba(91, 211, 255, 0.08);
      }
      .palette {
        display: flex;
        gap: 8px;
        align-items: center;
      }
      .swatch {
        width: 18px;
        height: 18px;
        border-radius: 4px;
        border: 1px solid #0008;
      }
      .hint {
        font-size: 11px;
        opacity: 0.85;
      }
    </style>
  </head>
  <body>
    <div class="wrap">
      <div class="title">
        <span class="glow-dot"></span><span>Entropy drawing</span>
      </div>

      <div class="panel">
        <div class="row">
          <input
            id="seedInput"
            type="text"
            spellcheck="false"
            placeholder="enter hex (e.g. deadbeefcafefeed) — arbitrary length"
          />
          <button id="randomBtn" class="primary">Random</button>
          <button id="renderBtn">Render</button>
          <button id="copyBtn">Copy link</button>
        </div>
        <div class="hint" style="margin-top: 6px">
          URL carries <code>?seed=...</code>. Share the link; they’ll see the
          same art.
        </div>
      </div>

      <div class="canvas-wrap">
        <canvas id="art" width="128" height="128"></canvas>
        <div class="meta">
          <div>Palette:</div>
          <div class="palette" id="palette"></div>
          <div class="badges">
            <span class="badge" id="modeBadge">mode: —</span>
            <span class="badge" id="blockBadge">block: —</span>
          </div>
          <div>Seed (normalized): <span id="normSeed">—</span></div>
          <div class="hint">
            Fixed colors: <code>#FFFBDE #91C8E4 #749BC2 #4682A9</code>
          </div>
        </div>
      </div>
    </div>

    <script>
      (() => {
        // Fixed palette
        const PALETTE_BASE = ["#FFFBDE", "#91C8E4", "#749BC2", "#4682A9"];

        const els = {
          seed: document.getElementById("seedInput"),
          rand: document.getElementById("randomBtn"),
          render: document.getElementById("renderBtn"),
          copy: document.getElementById("copyBtn"),
          canvas: document.getElementById("art"),
          palette: document.getElementById("palette"),
          modeBadge: document.getElementById("modeBadge"),
          blockBadge: document.getElementById("blockBadge"),
          normSeed: document.getElementById("normSeed"),
        };

        // Palette swatches
        PALETTE_BASE.forEach((c) => {
          const d = document.createElement("div");
          d.className = "swatch";
          d.style.background = c;
          els.palette.appendChild(d);
        });

        // --- helpers -------------------------------------------------------------
        const TAU = Math.PI * 2;

        function normalizeHex(s) {
          if (!s) return "";
          return (s + "")
            .replace(/^0x/i, "")
            .replace(/[^0-9a-fA-F]/g, "")
            .toLowerCase();
        }

        // FNV-1a (bytes from hex) -> 32-bit
        function hexToSeed32(hex) {
          if (hex.length === 0) return 0x811c9dc5 >>> 0;
          if (hex.length % 2 === 1) hex = "0" + hex;
          let h = 0x811c9dc5 >>> 0;
          for (let i = 0; i < hex.length; i += 2) {
            const b = parseInt(hex.slice(i, i + 2), 16);
            h ^= b;
            h = Math.imul(h, 0x01000193);
          }
          return h >>> 0;
        }

        function fmix32(a) {
          a ^= a >>> 16;
          a = Math.imul(a, 0x85ebca6b);
          a ^= a >>> 13;
          a = Math.imul(a, 0xc2b2ae35);
          a ^= a >>> 16;
          return a >>> 0;
        }

        function hash2D(seed, x, y) {
          let n = (seed + Math.imul((x | 0) + 0x9e3779b9, 0x85ebca6b)) >>> 0;
          n ^= Math.imul((y | 0) + 0x9e3779b9, 0xc2b2ae35);
          return fmix32(n);
        }

        // 4-way rotational canonical mapping
        function rot4Canonical(x, y, W, H) {
          const t0 = [x, y];
          const t1 = [W - 1 - y, x];
          const t2 = [W - 1 - x, H - 1 - y];
          const t3 = [y, H - 1 - x];
          const arr = [t0, t1, t2, t3];
          arr.sort((a, b) => a[0] - b[0] || a[1] - b[1]);
          return arr[0];
        }

        // mode engines: return color index (0..3) for pixel (x,y)
        function buildColorIndexer(seed, blockSize, paletteLen, W, H) {
          const cx = (W - 1) / 2,
            cy = (H - 1) / 2;
          const sectors = 16; // for polar sector modes

          return {
            // 0 none: hash on block coords
            0: (x, y) =>
              hash2D(seed, (x / blockSize) | 0, (y / blockSize) | 0) %
              paletteLen,

            // 1 vertical mirror
            1: (x, y) => {
              const sx = x < W / 2 ? x : W - 1 - x,
                sy = y;
              return (
                hash2D(seed, (sx / blockSize) | 0, (sy / blockSize) | 0) %
                paletteLen
              );
            },

            // 2 horizontal mirror
            2: (x, y) => {
              const sx = x,
                sy = y < H / 2 ? y : H - 1 - y;
              return (
                hash2D(seed, (sx / blockSize) | 0, (sy / blockSize) | 0) %
                paletteLen
              );
            },

            // 3 quad mirror (both)
            3: (x, y) => {
              const sx = x < W / 2 ? x : W - 1 - x;
              const sy = y < H / 2 ? y : H - 1 - y;
              return (
                hash2D(seed, (sx / blockSize) | 0, (sy / blockSize) | 0) %
                paletteLen
              );
            },

            // 4 main diagonal mirror (y = x)
            4: (x, y) => {
              let sx = x,
                sy = y;
              if (y > x) {
                sx = y;
                sy = x;
              } // reflect above diagonal
              return (
                hash2D(seed, (sx / blockSize) | 0, (sy / blockSize) | 0) %
                paletteLen
              );
            },

            // 5 anti-diagonal mirror (y = H-1-x)
            5: (x, y) => {
              let sx = x,
                sy = y;
              if (y > H - 1 - x) {
                // reflect across anti-diagonal
                const dx = H - 1 - y;
                sx = dx;
                sy = W - 1 - x;
              }
              return (
                hash2D(seed, (sx / blockSize) | 0, (sy / blockSize) | 0) %
                paletteLen
              );
            },

            // 6 4-fold rotational symmetry
            6: (x, y) => {
              const [sx, sy] = rot4Canonical(x, y, W, H);
              return (
                hash2D(seed, (sx / blockSize) | 0, (sy / blockSize) | 0) %
                paletteLen
              );
            },

            // 7 radial rings (quantized by blockSize)
            7: (x, y) => {
              const dx = x - cx,
                dy = y - cy;
              const r = Math.sqrt(dx * dx + dy * dy);
              const ring = Math.floor(r / blockSize);
              return fmix32(seed + ring * 0x9e37) % paletteLen;
            },

            // 8 polar sectors (like a kaleidoscope)
            8: (x, y) => {
              const dx = x - cx,
                dy = y - cy;
              let ang = Math.atan2(dy, dx);
              if (ang < 0) ang += TAU;
              const sec = Math.floor((ang / TAU) * sectors);
              // mirror every other sector into a canonical wedge
              const wedge = sec % 2 === 0 ? sec : sec - 1;
              const rbin = Math.floor(Math.hypot(dx, dy) / blockSize);
              return fmix32(seed ^ (wedge * 1315423911) ^ rbin) % paletteLen;
            },

            // 9 stripes (xor of block coords)
            9: (x, y) => {
              const bx = (x / blockSize) | 0,
                by = (y / blockSize) | 0;
              return ((bx ^ by) + (seed & 3)) % paletteLen;
            },

            // 10 checkerboard hashed
            10: (x, y) => {
              const bx = (x / blockSize) | 0,
                by = (y / blockSize) | 0;
              const parity = (bx + by) & 1;
              const h = hash2D(seed, bx, by);
              return (parity ? h >> 1 : h >> 3) % paletteLen;
            },
          };
        }

        function renderFromHex(hexIn, { updateUrl = true } = {}) {
          const hex = normalizeHex(hexIn);
          els.normSeed.textContent = hex || "(empty → default offset basis)";

          // Update URL for shareability
          if (updateUrl) {
            const url = new URL(window.location.href);
            if (hex) url.searchParams.set("seed", hex);
            else url.searchParams.delete("seed");
            history.replaceState(null, "", url.toString());
          }

          const seed = hexToSeed32(hex);
          const W = 128,
            H = 128;

          // block options (still deterministic)
          const blockOptions = [1, 2, 4, 8, 16];
          const blockSize =
            blockOptions[fmix32(seed + 0xbeef) % blockOptions.length];
          els.blockBadge.textContent = `block: ${blockSize} px`;

          // rotate palette order deterministically
          const rotation = fmix32(seed + 0x5a5a) % 4;
          const palette = PALETTE_BASE.map(
            (_, i) => PALETTE_BASE[(i + rotation) % 4]
          );

          // modes (expanded)
          const modeNames = [
            "none",
            "vertical",
            "horizontal",
            "quad",
            "diag",
            "anti-diag",
            "rot4",
            "rings",
            "sectors",
            "stripes",
            "checker",
          ];
          const MODE_COUNT = modeNames.length;
          const modeIdx = fmix32(seed + 0x1234) % MODE_COUNT;
          els.modeBadge.textContent = `mode: ${modeNames[modeIdx]}`;

          const indexers = buildColorIndexer(
            seed,
            blockSize,
            palette.length,
            W,
            H
          );
          const colorIndexAt = indexers[modeIdx];

          const ctx = els.canvas.getContext("2d", { willReadFrequently: true });
          const img = ctx.createImageData(W, H);
          const data = img.data;

          for (let y = 0; y < H; y++) {
            for (let x = 0; x < W; x++) {
              const cidx = colorIndexAt(x, y);
              const col = palette[cidx];
              const r = parseInt(col.slice(1, 3), 16);
              const g = parseInt(col.slice(3, 5), 16);
              const b = parseInt(col.slice(5, 7), 16);
              const i = (y * W + x) * 4;
              data[i + 0] = r;
              data[i + 1] = g;
              data[i + 2] = b;
              data[i + 3] = 255;
            }
          }
          ctx.putImageData(img, 0, 0);
        }

        function randomHex(len = 32) {
          if (window.crypto?.getRandomValues) {
            const bytes = new Uint8Array(Math.ceil(len / 2));
            crypto.getRandomValues(bytes);
            return Array.from(bytes, (b) => b.toString(16).padStart(2, "0"))
              .join("")
              .slice(0, len);
          }
          let s = "";
          while (s.length < len)
            s += Math.floor(Math.random() * 256)
              .toString(16)
              .padStart(2, "0");
          return s.slice(0, len);
        }

        // Wire up UI
        els.render.addEventListener("click", () =>
          renderFromHex(els.seed.value)
        );
        els.rand.addEventListener("click", () => {
          els.seed.value = randomHex(32);
          renderFromHex(els.seed.value);
        });
        els.copy.addEventListener("click", async () => {
          renderFromHex(els.seed.value, { updateUrl: true });
          try {
            await navigator.clipboard.writeText(window.location.href);
            els.copy.textContent = "Copied!";
            setTimeout(() => (els.copy.textContent = "Copy link"), 1000);
          } catch {
            els.copy.textContent = "Copy failed";
            setTimeout(() => (els.copy.textContent = "Copy link"), 1200);
          }
        });
        els.seed.addEventListener("keydown", (e) => {
          if (e.key === "Enter") renderFromHex(els.seed.value);
        });

        // Boot from URL or default
        const params = new URLSearchParams(window.location.search);
        const urlSeed = normalizeHex(params.get("seed") || "");
        els.seed.value = urlSeed || "deadbeefcafefeed8badf00d";
        renderFromHex(els.seed.value, { updateUrl: !urlSeed });
      })();
    </script>
  </body>
</html>
