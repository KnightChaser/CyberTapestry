<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Seeded Pixel Art (128×128)</title>
<style>
  :root { --bg:#0b0f14; --fg:#cdd6f4; --muted:#8a97a7; }
  * { box-sizing: border-box; }
  body {
    margin: 0; padding: 24px;
    background: radial-gradient(1200px 800px at 20% 10%, #0f1824 0%, #0b0f14 60%, #070a0f 100%);
    color: var(--fg); font-family: ui-monospace, SFMono-Regular, Consolas, "Liberation Mono", Menlo, monospace;
    display: grid; place-items: start center; gap: 18px;
  }
  .wrap { width: min(680px, 100%); display: grid; gap: 14px; }
  .row { display: flex; gap: 10px; align-items: center; flex-wrap: wrap; }
  input[type=text]{
    flex: 1 1 360px; padding: 10px 12px; font-size: 14px; letter-spacing: .3px;
    color: var(--fg); background: #111723; border: 1px solid #1b2230; border-radius: 10px;
    outline: none;
  }
  input[type=text]::placeholder{ color: var(--muted); }
  button{
    padding: 10px 14px; border: 1px solid #1b2230; background:#0e1522; color:var(--fg);
    border-radius: 10px; cursor: pointer;
  }
  button:hover{ background:#121c2b; }
  .palette { display:flex; gap:8px; align-items:center; }
  .swatch{ width:18px; height:18px; border-radius:4px; border:1px solid #0008; }
  .canvas-wrap{ display:flex; gap:18px; align-items:flex-start; }
  canvas{
    width: 512px; height: 512px; /* upscale for visibility */
    image-rendering: pixelated; image-rendering: crisp-edges;
    border-radius: 12px; background: #0a0f15; border:1px solid #1b2230;
  }
  .meta { color: var(--muted); font-size: 12px; line-height: 1.4; }
  .badge { padding:2px 6px; border-radius:6px; border:1px solid #1b2230; background:#0e1522; }
</style>
</head>
<body>
  <div class="wrap">
    <div class="row">
      <input id="seedInput" type="text" spellcheck="false" placeholder="enter hex (e.g. deadbeefcafefeed) — arbitrary length" />
      <button id="randomBtn">Random</button>
      <button id="renderBtn">Render</button>
    </div>

    <div class="canvas-wrap">
      <canvas id="art" width="128" height="128"></canvas>
      <div class="meta">
        <div>Palette:</div>
        <div class="palette" id="palette"></div>
        <div style="margin-top:10px">
          <span class="badge" id="modeBadge">mode: —</span>
          <span class="badge" id="blockBadge">block: —</span>
        </div>
        <div style="margin-top:10px">
          Seed (normalized): <span id="normSeed">—</span>
        </div>
      </div>
    </div>
  </div>

<script>
(() => {
  // Fixed palette (exactly as requested)
  const PALETTE_BASE = ["#FFFBDE", "#91C8E4", "#749BC2", "#4682A9"];

  const els = {
    seed: document.getElementById('seedInput'),
    rand: document.getElementById('randomBtn'),
    render: document.getElementById('renderBtn'),
    canvas: document.getElementById('art'),
    palette: document.getElementById('palette'),
    modeBadge: document.getElementById('modeBadge'),
    blockBadge: document.getElementById('blockBadge'),
    normSeed: document.getElementById('normSeed'),
  };

  // Draw static palette swatches
  PALETTE_BASE.forEach(c => {
    const d = document.createElement('div');
    d.className = 'swatch'; d.style.background = c;
    els.palette.appendChild(d);
  });

  // --- helpers -------------------------------------------------------------

  // Normalize hex: strip 0x, non-hex, lowercase
  function normalizeHex(s) {
    if (!s) return "";
    return (s + "")
      .replace(/^0x/i, "")
      .replace(/[^0-9a-fA-F]/g, "")
      .toLowerCase();
  }

  // Convert arbitrary-length hex to a 32-bit seed via FNV-1a over bytes
  function hexToSeed32(hex) {
    if (hex.length === 0) return 0x811c9dc5 >>> 0; // FNV offset basis fallback
    if (hex.length % 2 === 1) hex = '0' + hex;

    let h = 0x811c9dc5 >>> 0; // 32-bit FNV offset basis
    for (let i = 0; i < hex.length; i += 2) {
      const byte = parseInt(hex.slice(i, i + 2), 16);
      h ^= byte;
      // h *= FNV prime (mod 2^32)
      h = Math.imul(h, 0x01000193);
    }
    return h >>> 0;
  }

  // Murmur3 finalizer-ish mix for decent diffusion
  function fmix32(a) {
    a ^= a >>> 16; a = Math.imul(a, 0x85ebca6b);
    a ^= a >>> 13; a = Math.imul(a, 0xc2b2ae35);
    a ^= a >>> 16; return a >>> 0;
  }

  // 2D hash from seed, x, y (block coordinates), returns uint32
  function hash2D(seed, x, y) {
    let n = (seed + Math.imul((x|0) + 0x9e3779b9, 0x85ebca6b)) >>> 0;
    n ^= Math.imul((y|0) + 0x9e3779b9, 0xc2b2ae35);
    return fmix32(n);
  }

  // Deterministic “random” choice from an array using a key
  function pick(array, key) {
    return array[key % array.length];
  }

  // Symmetry mapping: returns source (sx,sy) to sample for pixel (x,y)
  function makeSymmetry(mode) {
    // 0: none, 1: vertical mirror, 2: horizontal mirror, 3: quad (both)
    return function map(x, y, W, H) {
      let sx = x, sy = y;
      if (mode === 1 && x >= W/2) sx = W - 1 - x;
      else if (mode === 2 && y >= H/2) sy = H - 1 - y;
      else if (mode === 3) {
        if (x >= W/2) sx = W - 1 - x;
        if (y >= H/2) sy = H - 1 - y;
      }
      return [sx, sy];
    };
  }

  // Render: deterministic pixel art from seed
  function renderFromHex(hexIn) {
    const hex = normalizeHex(hexIn);
    els.normSeed.textContent = hex || "(empty → default offset basis)";

    const seed = hexToSeed32(hex);

    // Deterministic mode & block size
    const modes = ["none", "vertical", "horizontal", "quad"];
    const modeIdx = fmix32(seed + 0x1234) % 4;
    const blockOptions = [1, 2, 4, 8, 16]; // must divide 128
    const blockSize = blockOptions[ fmix32(seed + 0xBEEF) % blockOptions.length ];

    els.modeBadge.textContent = `mode: ${modes[modeIdx]}`;
    els.blockBadge.textContent = `block: ${blockSize} px`;

    // Optionally rotate palette order to add variety (still same 4 colors)
    const rotation = fmix32(seed + 0x5A5A) % 4;
    const palette = PALETTE_BASE.map((_, i) => PALETTE_BASE[(i + rotation) % 4]);

    const W = 128, H = 128;
    const ctx = els.canvas.getContext('2d', { willReadFrequently: true });
    const img = ctx.createImageData(W, H);
    const data = img.data;

    const mapSym = makeSymmetry(modeIdx);

    // Draw per pixel using 2D hash on block coordinates
    for (let y = 0; y < H; y++) {
      for (let x = 0; x < W; x++) {
        const [sx, sy] = mapSym(x, y, W, H);
        const bx = (sx / blockSize) | 0;
        const by = (sy / blockSize) | 0;

        const h = hash2D(seed, bx, by);
        const colorIdx = h % 4;
        const col = palette[colorIdx];

        const r = parseInt(col.slice(1,3),16);
        const g = parseInt(col.slice(3,5),16);
        const b = parseInt(col.slice(5,7),16);

        const i = (y * W + x) * 4;
        data[i+0] = r;
        data[i+1] = g;
        data[i+2] = b;
        data[i+3] = 255;
      }
    }

    ctx.putImageData(img, 0, 0);
  }

  // Random hex generator (32 hex chars by default)
  function randomHex(len = 32) {
    if (window.crypto && crypto.getRandomValues) {
      const bytes = new Uint8Array(Math.ceil(len/2));
      crypto.getRandomValues(bytes);
      return Array.from(bytes, b => b.toString(16).padStart(2,'0')).join('').slice(0, len);
    }
    // Fallback
    let s = "";
    while (s.length < len) s += Math.floor(Math.random()*256).toString(16).padStart(2,'0');
    return s.slice(0, len);
  }

  // Wire up UI
  els.render.addEventListener('click', () => renderFromHex(els.seed.value));
  els.rand.addEventListener('click', () => {
    els.seed.value = randomHex(32);
    renderFromHex(els.seed.value);
  });
  els.seed.addEventListener('keydown', (e) => { if (e.key === 'Enter') renderFromHex(els.seed.value); });

  // First paint
  els.seed.value = "deadbeefcafefeed8badf00d";
  renderFromHex(els.seed.value);
})();
</script>
</body>
</html>

